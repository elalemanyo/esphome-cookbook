esphome:
  name: watertank-level
  friendly_name: watertank-level

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: esp-idf

logger:

api:
  encryption:
    key: !secret api_encryption_key

ota:
  - platform: esphome
    password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  power_save_mode: none
  fast_connect: true
  output_power: 8.5dB # IMPORTANT for C3 stability

  ap:
    ssid: "Watertank Level Hotspot"
    password: "12345678"

captive_portal:

# web_server:
#   port: 80

globals:
  - id: tank_min_distance
    type: float
    restore_value: no
    initial_value: '0.20' # Distance when tank is full (meters)
  - id: tank_max_distance
    type: float
    restore_value: no
    initial_value: '6.00' # Distance when tank is empty (meters)

sensor:
  - platform: ultrasonic
    id: tank_distance_1
    name: "Tank Distance #1"
    trigger_pin: GPIO4
    echo_pin: GPIO3
    update_interval: 1s
    unit_of_measurement: m
    pulse_time: 20us
    timeout: 6m

  - platform: template
    name: "% Tank Level #1"
    lambda: |-
      float distance = round(id(tank_distance_1).state * 100) / 100;  // Round to 2 decimals
      float min_dist = id(tank_min_distance);
      float max_dist = id(tank_max_distance);
      float range = max_dist - min_dist;

      if (distance <= min_dist) {
        return 100;
      }
      else if (distance >= max_dist) {
        return 0;
      } else {
        return int(100 - ((distance - min_dist) / range * 100));
      }
    update_interval: 1s

  - platform: ultrasonic
    id: tank_distance_2
    name: "Tank Distance #2"
    trigger_pin: GPIO8
    echo_pin: GPIO9
    update_interval: 1s
    unit_of_measurement: m
    pulse_time: 20us
    timeout: 6m

  - platform: template
    name: "% Tank Level #2"
    lambda: |-
      float distance = round(id(tank_distance_2).state * 100) / 100;  // Round to 2 decimals
      float min_dist = id(tank_min_distance);
      float max_dist = id(tank_max_distance);
      float range = max_dist - min_dist;

      if (distance <= min_dist) {
        return 100;
      }
      else if (distance >= max_dist) {
        return 0;
      } else {
        return int(100 - ((distance - min_dist) / range * 100));
      }
    update_interval: 1s
